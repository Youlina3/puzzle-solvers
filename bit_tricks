#!/usr/bin/env python

from __future__ import print_function
from z3 import *

def validate_sign_by_shift():
  """
  sign = v >> (sizeof(int) * CHAR_BIT - 1);
  """
  v = BitVec("v", 32)
  s = v >> 31
  print("Validating sign trick:")
  prove(
    Or(
      And(v < 0, s == -1),
      And(v >= 0, s == 0),
    )
  )

def validate_opposite_sign_by_xor():
  """
  int x, y;               // input values to compare signs
  bool f = ((x ^ y) < 0); // true iff x and y have opposite signs
  """
  x = BitVec("x", 32)
  y = BitVec("y", 32)
  f = (x^y) < 0

  print("Validating sign trick:")
  prove(
    Or(
      And(x >= 0, y >= 0, f == False),
      And(x < 0, y < 0, f == False),
      And(x >= 0, y < 0, f == True),
      And(x < 0, y >= 0, f == True),
    )
  )

def validate_abs_without_branches_1():
  """
  int v;           // we want to find the absolute value of v
  unsigned int r;  // the result goes here
  int const mask = v >> sizeof(int) * CHAR_BIT - 1;
  r = (v + mask) ^ mask;
  """
  v = BitVec("v", 32)
  mask = v >> 31
  r = (v + mask) ^ mask
  print("Validating abs without branching, version 1")
  prove(
    Or(
      And(v >= 0, r==v),
      And(v < 0, r==-v)
    )
  )

def validate_abs_without_branches_2():
  """
  int v;           // we want to find the absolute value of v
  unsigned int r;  // the result goes here
  int const mask = v >> sizeof(int) * CHAR_BIT - 1;
  r = (v ^ mask) - mask;
  """
  v = BitVec("v", 32)
  mask = v >> 31
  r = (v^mask) - mask
  print("Validating abs without branching, version 2")
  prove(
    Or(
      And(v >= 0, r==v),
      And(v < 0, r==-v)
    )
  )


validate_sign_by_shift()
validate_opposite_sign_by_xor()
validate_abs_without_branches_1()
validate_abs_without_branches_2()


"""
Based on https://graphics.stanford.edu/~seander/bithacks.html
"""
